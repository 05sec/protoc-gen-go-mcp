// Code generated by protoc-gen-mcp-go. DO NOT EDIT.
// source: {{ .SourcePath }}

package {{ .GoPackage }}

import (
	"context"
	"github.com/mark3labs/mcp-go/mcp"
	mcpserver "github.com/mark3labs/mcp-go/server"
	"encoding/json"
	"google.golang.org/protobuf/encoding/protojson"
	"connectrpc.com/connect"
	grpc "google.golang.org/grpc"
)

var (
{{- range $key, $val := .Tools }}
	{{$key}}Tool = {{ printf "%#v" $val }}
{{- end }}
)

{{- range $key, $val := .Services }}
func Register{{$key}}McpHandler(s *mcpserver.MCPServer, srv {{$key}}Server) {
  {{- range $tool_name, $tool_val := $val }}
  s.AddTool({{$key}}_{{$tool_name}}Tool,func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req {{$tool_val.RequestType}}
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := srv.{{$tool_name}}(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
  })
  {{- end }}
}
{{- end }}

{{- range $serviceName, $methods := .Services }}
// Connect{{$serviceName}}Client is compatible with the connectrpc-go client interface.
type Connect{{$serviceName}}Client interface {
  {{- range $methodName, $tool := $methods }}
  {{$methodName}}(ctx context.Context, req *connect.Request[{{$tool.RequestType}}]) (*connect.Response[{{$tool.ResponseType}}], error)
  {{- end }}
}
{{ end }}

{{- range $key, $val := .Services }}
// ForwardToConnect{{$key}}Client registers a connectrpc client, to forward MCP calls to it.
func ForwardToConnect{{$key}}Client(s *mcpserver.MCPServer, client Connect{{$key}}Client) {
  {{- range $tool_name, $tool_val := $val }}
  s.AddTool({{$key}}_{{$tool_name}}Tool,func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req {{$tool_val.RequestType}}
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.{{$tool_name}}(ctx, connect.NewRequest(&req))
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp.Msg)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
  })
  {{- end }}
}
{{- end }}

{{- range $key, $val := .Services }}
// ForwardTo{{$key}}Service make MCP calls forward to a grpc conn
func ForwardTo{{$key}}(s *mcpserver.MCPServer, conn *grpc.ClientConn){
	ForwardTo{{$key}}Client(s, New{{$key}}Client(conn))
}

// ForwardTo{{$key}}Client registers a gRPC client, to forward MCP calls to it.
func ForwardTo{{$key}}Client(s *mcpserver.MCPServer, client {{$key}}Client) {
  {{- range $tool_name, $tool_val := $val }}
  s.AddTool({{$key}}_{{$tool_name}}Tool,func(ctx context.Context, request mcp.CallToolRequest) (*mcp.CallToolResult, error) {
		marshaled, err := json.Marshal(request.Params.Arguments)
		if err != nil {
			return nil, err
		}

		var req {{$tool_val.RequestType}}
		if err := (protojson.UnmarshalOptions{DiscardUnknown: true}).Unmarshal(marshaled, &req); err != nil {
			return nil, err
		}

		resp, err := client.{{$tool_name}}(ctx, &req)
		if err != nil {
			return nil, err
		}

		marshaled, err = (protojson.MarshalOptions{UseProtoNames: true, EmitDefaultValues: true}).Marshal(resp)
		if err != nil {
			return nil, err
		}
		return mcp.NewToolResultText(string(marshaled)), nil
  })
  {{- end }}
}
{{- end }}
